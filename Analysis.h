// Copyright (c) 2014-2019 Robert A. Alfieri
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
// Analysis.h - class for analyzing logs generated by Logger.h
//
//              range analysis
//              redundancy analysis
//              pipeline analysis
//              precision analysis
//
#ifndef _Analysis_h
#define _Analysis_h

#include <string>
#include <cmath>
#include <iostream>
#include <vector>
#include <map>

#include "Cordic.h"

template< typename T=int64_t, typename FLT=double >
class Analysis
{
public:
    Analysis( std::string file_name = "" );     // "" means use stdin
    ~Analysis();

private:
    std::istream *      in;
    bool                in_text;

    struct FuncInfo
    {
        size_t   func_i;
    };

    struct FrameInfo
    {
        size_t   func_i;
    };

    struct CordicInfo
    {
        size_t   cordic_i;
        bool     is_alive;
        uint32_t int_w;
        uint32_t frac_w;
        uint32_t n;
    };

    struct ValInfo
    {
        bool    is_alive;
        bool    is_assigned;
        size_t  cordic_i;
        size_t  opnd_i[3];
        bool    is_constant;
        FLT     constant;
        FLT     min;
        FLT     max;
    };

    using OP = typename Cordic<T,FLT>::OP;

    std::map<std::string, OP>                  ops;
    std::map<std::string, FuncInfo>            funcs;
    std::vector<FrameInfo>                     stack;
    std::map<uint64_t, CordicInfo>             cordics;
    std::map<uint64_t, ValInfo>                vals;
};

//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
// 
// IMPLEMENTATION  IMPLEMENTATION  IMPLEMENTATION
//
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
//-----------------------------------------------------
enum class Kind
{
    cordic_constructed,
    cordic_destructed,
    enter,
    leave,
    constructed,
    destructed,
    op1, 
    op2, 
    op2i, 
    op2f, 
    op3, 
    op4, 
};

template< typename T, typename FLT >
static inline void _die( std::string msg )
{
    std::cout << "ERROR: " << msg << "\n";
    exit( 1 );
}

template< typename T, typename FLT >
static inline std::string _parse_string( char *& c )
{
    (void)c;
    return "";
}

template< typename T, typename FLT >
static inline Kind _parse_kind( char *& c )
{
    (void)c;
    return Kind(0);
}

template< typename T, typename FLT >
static inline uint64_t _parse_addr( char *& c )
{
    (void)c;
    return 0;
}

template< typename T, typename FLT >
static inline T _parse_int( char *& c )
{
    (void)c;
    return 0;
}

template< typename T, typename FLT >
static inline FLT _parse_flt( char *& c )
{
    (void)c;
    return 0;
}

template< typename T, typename FLT >
Analysis<T,FLT>::Analysis( std::string file_name )
{
    in_text = file_name == "";
    if ( in_text ) {
        in = &std::cin;
    }

    // set up ops map
    for( uint32_t o = 0; o < Cordic<T,FLT>::OP_cnt; o++ )
    {
        std::string name = Cordic<T,FLT>::op_to_str( o );
        ops[name] = OP(o);
    }

    // assume parsing text at this point
    std::string line;
    char cs[1024];
    while( std::getline( *in, line ) )
    {
        strcpy( cs, line.c_str() );
        char * c = cs;
        const Kind kind = _parse_kind<T,FLT>( c );
        switch( kind )
        {
            case Kind::cordic_constructed:
            {
                CordicInfo info;
                uint64_t cordic = _parse_addr<T,FLT>( c );
                info.is_alive   = true;
                info.int_w      = _parse_int<T,FLT>( c );
                info.frac_w     = _parse_int<T,FLT>( c );
                info.n          = _parse_int<T,FLT>( c );
                auto it = cordics.find( cordic );
                cassert( it == cordics.end() || !it->second.is_alive, "Cordic reconstructed before previous was destructed" );
                cordics[cordic] = info;
                break;
            }

            case Kind::cordic_destructed:
            {
                uint64_t cordic = _parse_addr<T,FLT>( c );
                auto it = cordics.find( cordic );
                cassert( it != cordics.end() && it->second.is_alive, "Cordic destructed before being constructed" );
                it->second.is_alive = false;
                break;
            }

            case Kind::enter:
            {
                std::string name = _parse_string<T,FLT>( c );
                auto it = funcs.find( name );
                if ( it == funcs.end() ) {
                    FuncInfo info;
                    info.func_i = funcs.size();
                    funcs[name] = info;
                    it = funcs.find( name );
                } 
                FrameInfo frame;
                frame.func_i = it->second.func_i;
                stack.push_back( frame );
                break;
            }

            case Kind::leave:
            {
                std::string name = _parse_string<T,FLT>( c );
                auto it = funcs.find( name );
                cassert( it != funcs.end(), "leave should have found function " + name );
                cassert( stack.size() > 0, "trying to leave routine " + name + " when stack is already empty" );
                FrameInfo& frame = stack[stack.size()-1];
                cassert( frame.func_i == it->second.func_i, "trying to leave a routine that's not at the top of the stack" );
                stack.pop_back();
                break;
            }

            case Kind::constructed:
            {
                ValInfo info;
                info.is_alive = true;
                info.is_assigned = false;
                info.is_constant = false;
                uint64_t val     = _parse_addr<T,FLT>( c );
                uint64_t cordic  = _parse_addr<T,FLT>( c );
                if ( cordic != 0 ) {
                    auto cit = cordics.find( val );
                    cassert( cit != cordics.end() && cit->second.is_alive, "val constructed using unknown cordic" );
                    info.cordic_i = cit->second.cordic_i;
                } else {
                    info.cordic_i = size_t(-1);
                }
                auto vit = vals.find( val );
                cassert( vit == vals.end() || !vit->second.is_alive, "val constructed before previous was desctructed" );
                break;
            }

            case Kind::destructed:
            {
                uint64_t val = _parse_addr<T,FLT>( c );
                auto it = vals.find( val );
                cassert( it != vals.end() && it->second.is_alive, "val destructed before being constructed" );
                it->second.is_alive = false;
                break;
            }

            case Kind::op1:
            case Kind::op2:
            case Kind::op3:
            case Kind::op4:
            {
                std::string name = _parse_string<T,FLT>( c );
                OP op = ops[name];
                uint32_t opnd_cnt = uint32_t(kind) - uint32_t(Kind::op1);
                uint64_t opnd[4];
                for( uint32_t i = 0; i < opnd_cnt; i++ )
                {
                    opnd[i] = _parse_addr<T,FLT>( c );
                    auto it = vals.find( opnd[i] );
                    cassert( it != vals.end() && it->second.is_alive, name + " opnd[i] does not exist" );
                    if ( i == 0 && op == OP::assign ) {
                        it->second.is_assigned = true;
                    } else {
                        cassert( it->second.is_assigned, name + " opnd[i] used when not previously assigned" );
                    }
                }
                break;
            }

            case Kind::op2i:
            {
                std::string name = _parse_string<T,FLT>( c );
                OP op = ops[name];
                cassert( op == OP::lshift || op == OP::rshift, "op2i allowed only for shifts" );
                uint64_t opnd1 = _parse_addr<T,FLT>( c );
                T        opnd2 = _parse_int<T,FLT>( c );
                break;
            }

            case Kind::op2f:
            {
                std::string name = _parse_string<T,FLT>( c );
                OP op = ops[name];
                cassert( op == OP::make_constant, "op2f allowed only for make_constant" );
                uint64_t opnd1 = _parse_addr<T,FLT>( c );
                FLT      opnd2 = _parse_flt<T,FLT>( c );
                break;
            }

            default:
            {
                _die<T,FLT>( "unexpected kind" );
                break;
            }
        }
    }
}

template< typename T, typename FLT >
Analysis<T,FLT>::~Analysis()
{
}

#endif
